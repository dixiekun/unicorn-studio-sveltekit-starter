{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.25,"trackMouse":0,"mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos; vec3 getColor(int index) { switch(index) { case 0: return vec3(1, 1, 0.8941176470588236); case 1: return vec3(0, 0, 0); case 2: return vec3(0, 0, 0); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(1, 1, 0.8941176470588236); }void main() {vec2 uv = vTextureCoord; vec2 pos = vec2(0.517304189435337, 0.5160291438979964) + mix(vec2(0), (uMousePos-0.5), 0.0000); uv -= pos; uv /= (0.5240*2.); uv = rotate(uv, (0.1593 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1.); fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true}},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradientFill","usesPingPong":false,"speed":0.25,"trackMouse":0,"mouseMomentum":0,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime; vec3 getColor(int index) { switch(index) { case 0: return vec3(0.27058823529411763, 0.10196078431372549, 0.0392156862745098); case 1: return vec3(1, 0.6823529411764706, 0.5294117647058824); case 2: return vec3(0.8, 0.41568627450980394, 0.22745098039215686); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }uniform vec2 uMousePos; uniform vec2 uResolution;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }float rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453); }vec3 linear_from_srgb(vec3 rgb) { return pow(rgb, vec3(2.2)); }vec3 srgb_from_linear(vec3 lin) { return pow(lin, vec3(1.0/2.2)); }vec3 oklab_mix(vec3 lin1, vec3 lin2, float a) { const mat3 kCONEtoLMS = mat3( 0.4121656120, 0.2118591070, 0.0883097947, 0.5362752080, 0.6807189584, 0.2818474174, 0.0514575653, 0.1074065790, 0.6302613616); const mat3 kLMStoCONE = mat3( 4.0767245293, -1.2681437731, -0.0041119885, -3.3072168827, 2.6093323231, -0.7034763098, 0.2307590544, -0.3411344290, 1.7068625689); vec3 lms1 = pow( kCONEtoLMS*lin1, vec3(1.0/3.0) ); vec3 lms2 = pow( kCONEtoLMS*lin2, vec3(1.0/3.0) ); vec3 lms = mix( lms1, lms2, a ); lms *= 1.0+0.025*a*(1.0-a); return kLMStoCONE*(lms*lms*lms); }vec3 getGradientColor(float position) { position = clamp(position, 0.0, 1.0); for (int i = 0; i < 3 - 1; i++) { float colorPosition = float(i) / float(3 - 1); float nextColorPosition = float(i + 1) / float(3 - 1); if (position <= nextColorPosition) { float mixFactor = (position - colorPosition) / (nextColorPosition - colorPosition); vec3 linStart = linear_from_srgb(getColor(i)); vec3 linEnd = linear_from_srgb(getColor(i + 1)); vec3 mixedLin = oklab_mix(linStart, linEnd, mixFactor); return srgb_from_linear(mixedLin); } } return getColor(3 - 1); }out vec4 fragColor;vec3 applyColorToPosition(float position) { vec3 color = vec3(0); position -= (uTime * 0.01 + 0.0000); float cycle = floor(position); bool reverse = int(cycle) % 2 == 0; float animatedPos = reverse ? 1.0 - fract(position) : fract(position);color = getGradientColor(animatedPos); float dither = rand(gl_FragCoord.xy) * 0.005; color += dither; return color; }vec3 conicalGrad(vec2 uv) { float angle = atan(uv.y, uv.x); float normalizedAngle = angle / (2.0 * 3.14159265359) + 0.5; float doubledAngle = 2.0 * normalizedAngle; doubledAngle = doubledAngle > 1. ? 2.0 - doubledAngle : doubledAngle; float position = clamp(doubledAngle, 0.0, 1.0); return applyColorToPosition(position); }vec3 getGradient(vec2 uv) { return conicalGrad(uv); }vec3 getColor(vec2 uv) { switch(3) { case 1: return vec3(0.27058823529411763, 0.10196078431372549, 0.0392156862745098); break; default: return getGradient(uv); break; } }void main() { vec2 uv = vTextureCoord; vec2 res = uResolution; vec2 pos = vec2(0.40619307832422585, 0.4242258652094718) + mix(vec2(0), (uMousePos-0.5), 0.0000); uv -= pos; uv /= (0.1520*2.); uv = rotate(uv, (0.0889 - 0.5) * 2. * 3.14159265); vec4 color = vec4(getColor(uv), 1); vec4 bg = texture(uTexture, vTextureCoord);color.rgb = mix(bg.rgb, color.rgb, 1.0000); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":false,"uniforms":{},"isBackground":false}},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"fbm","usesPingPong":false,"speed":0.25,"trackMouse":0,"mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;float ease (int easingFunc, float t) { return t; }vec3 hash33(vec3 p3) { p3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787)); p3 += dot(p3, p3.yxz + 19.19); return -1.0 + 2.0 * fract(vec3( (p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x )); }float perlin_noise(vec3 p) { vec3 pi = floor(p); vec3 pf = p - pi;vec3 w = pf * pf * (3.0 - 2.0 * pf);float n000 = dot(pf - vec3(0.0, 0.0, 0.0), hash33(pi + vec3(0.0, 0.0, 0.0))); float n100 = dot(pf - vec3(1.0, 0.0, 0.0), hash33(pi + vec3(1.0, 0.0, 0.0))); float n010 = dot(pf - vec3(0.0, 1.0, 0.0), hash33(pi + vec3(0.0, 1.0, 0.0))); float n110 = dot(pf - vec3(1.0, 1.0, 0.0), hash33(pi + vec3(1.0, 1.0, 0.0))); float n001 = dot(pf - vec3(0.0, 0.0, 1.0), hash33(pi + vec3(0.0, 0.0, 1.0))); float n101 = dot(pf - vec3(1.0, 0.0, 1.0), hash33(pi + vec3(1.0, 0.0, 1.0))); float n011 = dot(pf - vec3(0.0, 1.0, 1.0), hash33(pi + vec3(0.0, 1.0, 1.0))); float n111 = dot(pf - vec3(1.0, 1.0, 1.0), hash33(pi + vec3(1.0, 1.0, 1.0)));float nx00 = mix(n000, n100, w.x); float nx01 = mix(n001, n101, w.x); float nx10 = mix(n010, n110, w.x); float nx11 = mix(n011, n111, w.x);float nxy0 = mix(nx00, nx10, w.y); float nxy1 = mix(nx01, nx11, w.y);float nxyz = mix(nxy0, nxy1, w.z);return nxyz; } const float PI = 3.14159265359; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }mat2 rotHalf = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));float fbm (in vec3 st) { float value = 0.0; float amp = .25; float frequency = 0.; float aM = (0.1 + 0.5000 * .65); vec2 shift = vec2(100.0); for (int i = 0; i < 6; i++) { value += amp * perlin_noise(st); st.xy *= rotHalf * 2.5; st.xy += shift; amp *= aM; } return value; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y; float multiplier = 6.0 * (0.2000 / ((aspectRatio + 1.) / 2.));vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); vec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000)); float mDist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.0000))); vec2 st = ((uv - pos) * vec2(aspectRatio, 1)) * multiplier * aspectRatio; st = rot(0.0000 * -1. * 2.0 * PI) * st; vec2 drift = vec2(uTime * 0.005) * (0.5000 * 2.);float time = uTime * 0.025;vec2 r = vec2( fbm(vec3(st - drift + vec2(1.7, 9.2), 0.0000*25. + time)), fbm(vec3(st - drift + vec2(8.2, 1.3), 0.0000*25. + time)) );float f = fbm(vec3(st + r - drift, 0.0000*25. + time)) * 0.5000;vec2 offset = (f * 2. + (r * 0.5000));vec4 color = texture(uTexture, uv + offset * mDist); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false}},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"beam","usesPingPong":false,"speed":0.3,"trackMouse":0.07,"mouseMomentum":0,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; precision highp int;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }uint fibonacciHash(uint x) { const uint FIB_HASH = 2654435769u; uint hash = x * FIB_HASH; hash ^= hash >> 16; hash *= 0x85ebca6bu; hash ^= hash >> 13; hash *= 0xc2b2ae35u; hash ^= hash >> 16; return hash; }float randFibo(vec2 xy) { uint x_bits = floatBitsToUint(xy.x); uint y_bits = floatBitsToUint(xy.y); uint y_hash = fibonacciHash(y_bits); uint x_xor_y = x_bits ^ y_hash; uint final_hash = fibonacciHash(x_xor_y); return float(final_hash) / float(0xffffffffu); }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }vec3 drawLine(vec2 uv, vec2 center, float scale, float angle) { float radAngle = -angle * TWO_PI; float phase = fract(uTime * 0.01 + 0.5000) * (3. * max(1., scale)) - (1.5 * max(1., scale));vec2 direction = vec2(cos(radAngle), sin(radAngle));vec2 centerToPoint = uv - center;float projection = dot(centerToPoint, direction);float distToLine = length(centerToPoint - projection * direction);float lineRadius = 0.7700 * 0.25; float brightness = lineRadius / (1. - smoothstep(0.4, 0., distToLine + 0.02));float glowRadius = scale; float glow = smoothstep(glowRadius, 0.0, abs(projection - phase));return brightness * (1.-distToLine)*(1.-distToLine) * vec3(0, 0.12156862745098039, 0.054901960784313725) * glow; }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0700); return drawLine(uv, pos, 0.8000, -0.1722); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 1.0000); result += dither;vec4 color = vec4(result, max(bg.a, luma(beam))); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false}},{"breakpoints":[],"visible":true,"locked":false,"aspectRatio":1,"layerName":"","userDownsample":1,"isElement":true,"opacity":1,"effects":[],"displace":0,"trackMouse":0,"anchorPoint":"center","mouseMomentum":0,"blendMode":"SOFT_LIGHT","bgDisplace":0,"mask":1,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":"1","dispersion":0,"axisTilt":0.14,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"image","imageLoaded":false,"width":450,"widthMode":"fixed","height":490.4137235116044,"heightMode":"fixed","left":0.5,"leftMode":"relative","top":0.5,"topMode":"relative","rotation":0,"fitToCanvas":1,"src":"https://assets.unicorn.studio/images/nB7PjkJUgbNJ5ArSGACf5QlhF4J3/dna.svg","naturalWidth":991,"naturalHeight":1080,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform vec2 uResolution; uniform vec2 uMousePos; uniform sampler2D uBgTexture; uniform sampler2D uPreviousLayerTexture; uniform sampler2D uTexture; uniform int uSampleBg;vec3 blend (int blendMode, vec3 src, vec3 dst) { return vec3((src.x <= 0.5) ? (dst.x - (1.0 - 2.0 * src.x) * dst.x * (1.0 - dst.x)) : (((src.x > 0.5) && (dst.x <= 0.25)) ? (dst.x + (2.0 * src.x - 1.0) * (4.0 * dst.x * (4.0 * dst.x + 1.0) * (dst.x - 1.0) + 7.0 * dst.x)) : (dst.x + (2.0 * src.x - 1.0) * (sqrt(dst.x) - dst.x))), (src.y <= 0.5) ? (dst.y - (1.0 - 2.0 * src.y) * dst.y * (1.0 - dst.y)) : (((src.y > 0.5) && (dst.y <= 0.25)) ? (dst.y + (2.0 * src.y - 1.0) * (4.0 * dst.y * (4.0 * dst.y + 1.0) * (dst.y - 1.0) + 7.0 * dst.y)) : (dst.y + (2.0 * src.y - 1.0) * (sqrt(dst.y) - dst.y))), (src.z <= 0.5) ? (dst.z - (1.0 - 2.0 * src.z) * dst.z * (1.0 - dst.z)) : (((src.z > 0.5) && (dst.z <= 0.25)) ? (dst.z + (2.0 * src.z - 1.0) * (4.0 * dst.z * (4.0 * dst.z + 1.0) * (dst.z - 1.0) + 7.0 * dst.z)) : (dst.z + (2.0 * src.z - 1.0) * (sqrt(dst.z) - dst.z)))); }const float STEPS = 24.0; const float PI = 3.1415926;vec2 perspectiveUV(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 centeredUV = uv - 0.5; centeredUV.x *= aspectRatio; float strength = 1.0 + (vVertexPosition.z * 0.1400); vec2 perspectiveUV = centeredUV / strength; perspectiveUV.x /= aspectRatio; perspectiveUV += 0.5; return perspectiveUV; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000); uv = perspectiveUV(uv) - pos; vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); } vec4 color = texture(uTexture, uv);if (1.0000 == 1.00) { if(1 == 2) { background *= (1. - color.a); color = background; } else { background *= color.a; color.rgb = background.rgb; color.rgb = 0.0000 > 0. ? mix(vec3(0, 0, 0), color.rgb, color.a) : color.rgb; color.a = min(1., color.a + 0.0000); if(1 == 1) { vec4 previousLayer = texture(uPreviousLayerTexture, vTextureCoord); color = mix(previousLayer, color/max(color.a, 0.0001), color.a * 1.0000); } } fragColor = color; return; }if (12 > 0) { vec3 unpremultColor = color.rgb / max(color.a, 0.0001); vec3 blendedColor = blend(12, unpremultColor, background.rgb); color = vec4(blendedColor, 1.0) * (color.a * 1.0000); color = color + background * (1.0 - color.a); } else { color = mix(background, color + background * (1.0 - color.a), 1.0000); }fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"uniforms":{}}},{"breakpoints":[],"visible":true,"locked":false,"aspectRatio":1.6,"layerName":"codex","userDownsample":1,"isElement":true,"opacity":0.6,"effects":["f4bdc97f-e276-43a5-a058-cae4631bc5ac","957d0f84-9170-4ac8-84fe-7eb292ee603f","5001c6e0-3a5d-4524-8824-fee1607706b7","19201958-6101-4853-86aa-ae32a529aa20"],"displace":0,"trackMouse":0,"anchorPoint":"topLeft","mouseMomentum":0,"blendMode":"SCREEN","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"shape","width":511,"widthMode":"fixed","height":549,"heightMode":"fixed","left":0.625,"leftMode":"relative","top":0.35444444444444445,"topMode":"relative","rotation":0,"pos":{"type":"Vec2","_x":0.5,"_y":0.5},"borderRadius":0,"gradientAngle":0,"strokeWidth":0,"coords":[[0,0],[511,0],[511,549],[0,549]],"fill":["#000000"],"fitToCanvas":false,"gradientType":"linear","type":"rectangle","stroke":["#000000"],"numSides":3,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform vec2 uResolution; uniform vec2 uMousePos; uniform sampler2D uBgTexture; uniform sampler2D uPreviousLayerTexture; uniform sampler2D uTexture; uniform int uSampleBg;vec3 blend (int blendMode, vec3 src, vec3 dst) { return 1. - (1. - src) * (1. - dst); }const float STEPS = 24.0; const float PI = 3.1415926;vec2 perspectiveUV(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 centeredUV = uv - 0.5; centeredUV.x *= aspectRatio; float strength = 1.0 + (vVertexPosition.z * 0.0000); vec2 perspectiveUV = centeredUV / strength; perspectiveUV.x /= aspectRatio; perspectiveUV += 0.5; return perspectiveUV; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000); uv = perspectiveUV(uv) - pos; vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); } vec4 color = texture(uTexture, uv);if (0.0000 == 1.00) { if(0 == 2) { background *= (1. - color.a); color = background; } else { background *= color.a; color.rgb = background.rgb; color.rgb = 0.0000 > 0. ? mix(vec3(0, 0, 0), color.rgb, color.a) : color.rgb; color.a = min(1., color.a + 0.0000); if(0 == 1) { vec4 previousLayer = texture(uPreviousLayerTexture, vTextureCoord); color = mix(previousLayer, color/max(color.a, 0.0001), color.a * 0.6000); } } fragColor = color; return; }if (4 > 0) { vec3 unpremultColor = color.rgb / max(color.a, 0.0001); vec3 blendedColor = blend(4, unpremultColor, background.rgb); color = vec4(blendedColor, 1.0) * (color.a * 0.6000); color = color + background * (1.0 - color.a); } else { color = mix(background, color + background * (1.0 - color.a), 0.6000); }fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"uniforms":{}}},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"mouseDraw","usesPingPong":true,"animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform sampler2D uPingPongTexture; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }uint fibonacciHash(uint x) { const uint FIB_HASH = 2654435769u; uint hash = x * FIB_HASH; hash ^= hash >> 16; hash *= 0x85ebca6bu; hash ^= hash >> 13; hash *= 0xc2b2ae35u; hash ^= hash >> 16; return hash; }float randFibo(vec2 xy) { uint x_bits = floatBitsToUint(xy.x); uint y_bits = floatBitsToUint(xy.y); uint y_hash = fibonacciHash(y_bits); uint x_xor_y = x_bits ^ y_hash; uint final_hash = fibonacciHash(x_xor_y); return float(final_hash) / float(0xffffffffu); }const float PI = 3.1415926;out vec4 fragColor;vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }vec2 angleToDir(float angle) { float rad = angle * 2.0 * PI; return vec2(cos(rad), sin(rad)); }void main() { vec2 uv = vTextureCoord; vec2 pingpongUv = uv;vec3 mouseRgb = texture(uPingPongTexture, pingpongUv).rgb; vec3 mouseTrail = rgb2hsv(mouseRgb); float angle = mouseTrail.x; float strength = mouseTrail.z * (0.6900 * 5.0);vec2 direction = angleToDir(angle);vec4 bg = texture(uTexture, uv - (direction * 0.1 * strength * 0.0000)); vec4 color = vec4(0,0,0,1);color.rgb = vec3(strength * mix(mouseRgb, vec3(0.00392156862745098, 0.18823529411764706, 0.09019607843137255), 0.5000)); float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;if(1 > 0) { vec3 blendedRgb = blend(1, color.rgb + dither, bg.rgb); fragColor = vec4(mix(bg.rgb, blendedRgb, mouseTrail.z), 1.0); } else { fragColor = mix(bg, color, mouseTrail.z); } }","#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uPingPongTexture; uniform vec2 uPreviousMousePos; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;const float PI = 3.1415926; const float TWOPI = 6.2831852;out vec4 fragColor;vec3 hsv2rgb(vec3 c) { vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 angleToDir(float angle) { float rad = angle * 2.0 * PI; return vec2(cos(rad), sin(rad)); }vec2 liquify(vec2 st, vec2 dir) { float aspectRatio = uResolution.x / uResolution.y; st.x *= aspectRatio; float amplitude = 0.0025; float freq = 6.; for (float i = 1.0; i <= 5.0; i++) { st = st * rot(i / 5.0 * PI * 2.0); st += vec2( amplitude * cos(i * freq * st.y + uTime * 0.02 * dir.x), amplitude * sin(i * freq * st.x + uTime * 0.02 * dir.y) ); } st.x /= aspectRatio; return st; }vec3 calculateTrailContribution(vec2 mousePos, vec2 prevMousePos, vec2 uv, vec2 correctedUv, float aspectRatio, float radius) { vec2 dir = (mousePos - prevMousePos) * vec2(aspectRatio, 1.0); float angle = atan(dir.y, dir.x); if (angle < 0.0) angle += TWOPI; vec2 mouseVec = mousePos - prevMousePos; float mouseLen = length(mouseVec); vec2 mouseDir = mouseLen > 0.0 ? mouseVec / mouseLen : vec2(0.0); vec2 posToUv = (correctedUv - prevMousePos) * vec2(aspectRatio, 1.0); float projection = clamp(dot(posToUv, mouseDir * vec2(aspectRatio, 1.0)), 0.0, mouseLen * aspectRatio); vec2 closestPoint = prevMousePos * vec2(aspectRatio, 1.0) + mouseDir * vec2(aspectRatio, 1.0) * projection; float distanceToLine = distance(correctedUv, closestPoint); float s = (1.0 + radius)/(distanceToLine + radius) * radius; vec3 color = vec3(angle / TWOPI, 1.0, 1.0); vec3 pointColor = hsv2rgb(color); pointColor = pow(pointColor, vec3(2.2)); float intensity = pow(s, 10.0 * (1. - 0.5000 + 0.1)); return pointColor * intensity; }void main() { float aspectRatio = uResolution.x / uResolution.y; vec2 uv = vTextureCoord; vec2 correctedUv = (uv) * vec2(aspectRatio, 1.0);vec3 lastFrameColor = texture(uPingPongTexture, uv).rgb; vec3 lastFrameColorGamma = pow(lastFrameColor, vec3(2.2)); vec3 hsv = rgb2hsv(lastFrameColor); vec3 hsvGamma = rgb2hsv(lastFrameColorGamma); vec2 prevDir = angleToDir(hsv.x); float prevStrength = hsvGamma.z; vec2 dir = (uMousePos - uPreviousMousePos) * vec2(aspectRatio, 1.0); float dist = length(dir); float blurAmount = 0.03 * prevStrength; uv = uv - prevDir * blurAmount; uv = mix(uv, liquify(uv - prevDir * 0.005, prevDir), (1. - prevStrength) * 0.2500); lastFrameColor = texture(uPingPongTexture, uv).rgb; lastFrameColor = pow(lastFrameColor, vec3(2.2)); int numPoints = int(max(12.0, dist * 24.0)); float speedFactor = clamp(dist, 0.7, 1.3); float radius = mix(0.1, 0.7, 0.5000 * speedFactor); vec3 trailColor = vec3(0.0); int iter = min(numPoints, 24); for (int i = 0; i <= iter; i++) { float t = float(i) / float(numPoints); vec2 interpPos = mix(uPreviousMousePos, uMousePos, t); vec2 prevInterpPos = i > 0 ? mix(uPreviousMousePos, uMousePos, float(i-1) / float(numPoints)) : uPreviousMousePos; trailColor += calculateTrailContribution(interpPos, prevInterpPos, uv, correctedUv, aspectRatio, radius); } trailColor = trailColor / float(min(numPoints, 50) + 1); vec3 blurredLastFrame = vec3(0.0); float clampedDist = clamp(length(trailColor) * dist, 0.0, 1.0); float blurRadius = 0.005; blurredLastFrame += pow(texture(uPingPongTexture, uv + vec2(blurRadius, 0.0)).rgb, vec3(2.2)) * 0.2; blurredLastFrame += pow(texture(uPingPongTexture, uv + vec2(-blurRadius, 0.0)).rgb, vec3(2.2)) * 0.2; blurredLastFrame += pow(texture(uPingPongTexture, uv + vec2(0.0, blurRadius)).rgb, vec3(2.2)) * 0.2; blurredLastFrame += pow(texture(uPingPongTexture, uv + vec2(0.0, -blurRadius)).rgb, vec3(2.2)) * 0.2; blurredLastFrame += lastFrameColor * 0.2; vec3 draw = mix(blurredLastFrame, trailColor, clampedDist); draw *= pow(0.5000, 0.2); draw = pow(draw, vec3(1.0/2.2)); fragColor = vec4(draw, 1.0); }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }","#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":false,"uniforms":{},"isBackground":false}},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"ascii","usesPingPong":false,"texture":{"src":"https://assets.unicorn.studio/images/nB7PjkJUgbNJ5ArSGACf5QlhF4J3/codex.png","sampler":"uCustomTexture"},"trackMouse":0,"mouseMomentum":0,"parentLayer":"5001c6e0-3a5d-4524-8824-fee1607706b7","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform sampler2D uSprite; uniform sampler2D uCustomTexture;uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor;const float GLYPH_HEIGHT = 40.0; const float DEFAULT_NUM_SPRITES = 10.0; const float DEFAULT_NUM_ROWS = 6.0;void main() { vec2 uv = vTextureCoord; vec2 pos = vec2(0.46174863387978143, 0.6282331511839708) + mix(vec2(0), (uMousePos-0.5), 0.0000); float aspectRatio = uResolution.x / uResolution.y; float aspectCorrection = mix(aspectRatio, 1./aspectRatio, 0.5);float gridSize = (0.5000 + 0.01) * 0.05;float baseGrid = 1.0 / gridSize; vec2 cellSize = vec2(1.0/(baseGrid * aspectRatio), 1.0/baseGrid) * aspectCorrection; vec2 offsetUv = uv - pos; vec2 cell = floor(offsetUv / cellSize); vec2 cellCenter = (cell + 0.5) * cellSize; vec2 pixelatedCoord = cellCenter + pos; vec4 bg = texture(uTexture, vTextureCoord); vec4 color = texture(uTexture, pixelatedCoord);float luminance = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722)); luminance = mix(luminance, 1.0 - luminance, float(0));float scaleFactor = gridSize / GLYPH_HEIGHT;ivec2 customTextureSize = textureSize(uCustomTexture, 0); float customSpriteWidth = float(customTextureSize.x); float numSprites = mix(DEFAULT_NUM_SPRITES, customSpriteWidth / GLYPH_HEIGHT, float(6 == 6)); float numGlyphRows = mix(DEFAULT_NUM_ROWS, 1.0, float(6 == 6));float spriteIndex = clamp(floor(luminance * numSprites), 0.0, numSprites - 1.0); float glyphIndex = mix(5.0 - float(6), 0.0, float(6 == 6));float normalizedSpriteSizeX = 1.0 / numSprites; float normalizedSpriteSizeY = 1.0 / numGlyphRows;vec2 spriteSheetUV = vec2( spriteIndex * normalizedSpriteSizeX, glyphIndex / numGlyphRows );vec2 spriteSize = vec2(GLYPH_HEIGHT / aspectRatio, GLYPH_HEIGHT) * scaleFactor * aspectCorrection; vec2 localOffset = mod(uv - pos, spriteSize) / spriteSize;spriteSheetUV += vec2( localOffset.x * normalizedSpriteSizeX, localOffset.y * normalizedSpriteSizeY );vec4 spriteColor1 = texture(uCustomTexture, spriteSheetUV); vec4 spriteColor2 = texture(uSprite, spriteSheetUV); vec4 spriteColor = mix(spriteColor2, spriteColor1, float(6 == 6));float alpha = smoothstep(0.0, 1.0, spriteColor.r);vec3 cc = (color.rgb - spriteIndex * 0.04) * 1.4; vec3 col = mix(cc, vec3(0, 1, 1), float(0)); vec3 dithered = mix( mix(vec3(0.0), vec3(1.0), float(0)), col, alpha ); color.rgb = mix(bg.rgb, dithered, 1.0000); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false,"texture":{"src":"https://assets.unicorn.studio/media/ascii_spritesheet_larger.png","sampler":"uSprite"}}},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"vignette","usesPingPong":false,"trackMouse":0,"mouseMomentum":0,"parentLayer":"19201958-6101-4853-86aa-ae32a529aa20","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform vec2 uResolution;out vec4 fragColor; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); } void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); float luma = dot(color.rgb, vec3(0.299, 0.587, 0.114)); float displacement = (luma - 0.5) * 0.0000 * 0.5; vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0); vec2 skew = vec2(0.5000, 1.0 - 0.5000); float halfRadius = 0.1880 * 0.5; float innerEdge = halfRadius - 1.0000 * halfRadius * 0.5; float outerEdge = halfRadius + 1.0000 * halfRadius * 0.5; vec2 pos = vec2(0.8032786885245902, 0.5539162112932604); const float TWO_PI = 6.28318530718; vec2 scaledUV = uv * aspectRatio * rot(0.0135 * TWO_PI) * skew; vec2 scaledPos = pos * aspectRatio * rot(0.0135 * TWO_PI) * skew; float radius = distance(scaledUV, scaledPos); float falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius); vec3 finalColor;finalColor = mix(color.rgb, mix(color.rgb, vec3(0, 0, 0), 1.0000), falloff); color = mix(color * (1.-falloff), vec4(finalColor * color.a, color.a), 1.0000); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false}},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"wisps","usesPingPong":false,"speed":0.04,"trackMouse":0,"mouseMomentum":0,"parentLayer":"f4bdc97f-e276-43a5-a058-cae4631bc5ac","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor; const float PI = 3.14159265359; mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 hash(vec2 p) { p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3))); return -1.0 + 2.0 * fract(sin(p) * 43758.5453123); }float luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }vec4 voronoi_static(vec2 st) { vec2 i_st = floor(st); vec2 f_st = fract(st);float m_dist = 1.0; float wander = 0.1400 * uTime * 0.2; vec2 m_point; vec2 cell_id;for (int y = -1; y <= 1; y++) { for (int x = -1; x <= 1; x++) { vec2 neighbor = vec2(float(x), float(y)); vec2 point = hash(i_st + neighbor); point = 0.5 + 0.5 * sin(5. + wander + 6.2831 * point); vec2 diff = neighbor + point - f_st; float dist = length(diff); if (dist < m_dist) { m_dist = dist; m_point = point; cell_id = i_st + neighbor; } } } return vec4(m_dist, m_point, hash(cell_id).x); }void main() { vec2 uv = vTextureCoord;vec4 bg = texture(uTexture, uv);vec4 color = vec4(0,0,0,1); vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1);vec2 mPos = mix(vec2(0), (uMousePos-0.5), 0.0000);uv -= vec2(0.5774134790528234, 0.4941712204007286); uv *= aspectRatio; uv = uv * rot(0.0000 * 2. * PI); uv *= 40. * 0.4300; uv *= mix(vec2(1), vec2(1, 0), 0.0000); uv /= aspectRatio;mPos = mPos * rot(0.0000 * -2. * PI);vec2 st1 = uv - (mPos * 30. * 0.4300); vec2 st2 = uv - (mPos * 40. * 0.4300);vec2 mouse1 = st1 + vec2(0, uTime * 0.5000 * -0.05); vec2 mouse2 = st2 + vec2(0, uTime * 0.5000 * -0.05);vec4 voro_static = voronoi_static(mouse1 * aspectRatio); vec4 voro_static2 = voronoi_static(mouse2 * aspectRatio + vec2(10)); float dist = smoothstep(0., 0.8, voro_static.x); float dist2 = smoothstep(0., 0.8, voro_static2.x);float shimmer1 = mix(1., (sin(dot(voro_static.yz, vec2(1.0)) * 10. + voro_static.w * 5.0 + uTime * 0.5) + 1.), 0.5400); float shimmer2 = mix(1., (sin(dot(voro_static2.yz, vec2(1.0)) * 10. + voro_static2.w * 5.0 + uTime * 0.5) + 1.), 0.5400); float radius1 = 0.02 * 0.5100 * shimmer1; float radius2 = 0.04 * 0.5100 * shimmer2; vec3 pass1 = vec3(radius1/dist); vec3 pass2 = vec3(radius2/dist2); color.rgb = (pass1 + pass2) * vec3(1, 1, 1) * mix(1., bg.r, 0.0000); color.r = clamp(color.r, 0., 1.); color.g = clamp(color.g, 0., 1.); color.b = clamp(color.b, 0., 1.);color = vec4(color.rgb, max(bg.a, luma(color.rgb))); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false}},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"blinds","usesPingPong":false,"speed":0.01,"trackMouse":0,"mouseMomentum":0,"parentLayer":"957d0f84-9170-4ac8-84fe-7eb292ee603f","animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;float ease (int easingFunc, float t) { return t; }const float STEPS = 10.0; const float PI = 3.14159265359;mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 scaleAspect(vec2 st, float aspectRatio) { return st * vec2(aspectRatio, 1.0); }vec2 unscaleAspect(vec2 st) { float aspectRatio = uResolution.x / uResolution.y; return st * vec2(1.0/aspectRatio, 1.0); }vec2 rotate(vec2 st, float angle) { float s = sin(angle); float c = cos(angle); mat2 rot = mat2(c, -s, s, c); return rot * st; }struct StructFunc { vec2 st; vec3 distort; };StructFunc style0(vec2 st, vec2 pos, float divisions, float dist, float amount, vec3 first, vec3 second, vec3 third) { float segment = fract((st.y + 1. - pos.y - 1. + uTime * 0.01) * divisions); segment = mix(segment, smoothstep(0.0, 0.5, segment) - smoothstep(0.5, 1.0, segment), 0.0000); vec3 distort = mix(mix(first, second, segment * 2.), mix(second, third, (segment - 0.5) / (1. - 0.5)), step(0.5, segment)); st.y -= pow(distort.r, dist) / 10. * amount; st.y += pow(distort.b, dist) / 10. * amount;st = rot(0.0000 * 2. * PI) * (st - pos) + pos; st = unscaleAspect(st);return StructFunc(st, distort); }StructFunc getStyle(vec2 st, vec2 pos, float divisions, float dist, float amount, vec3 first, vec3 second, vec3 third) { return style0(st, pos, divisions, dist, amount, first, second, third); }vec4 blinds(vec2 st, float mDist) { float aspectRatio = uResolution.x / uResolution.y; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos - 0.5), 0.0000) * floor(1.0000); pos = scaleAspect(pos, aspectRatio); st = scaleAspect(st, aspectRatio);st = rotate(st - pos, -1. * 0.0000 * 2.0 * PI) + pos;vec3 first = vec3(1, 0, 0); vec3 second = vec3(0, 1, 0); vec3 third = vec3(0, 0, 1); float divisions = 2. + 0.5000 * 30.; float dist = 0.2000 * 4. + 1.; float amount = 0.5000 * mDist;StructFunc result = getStyle(st, pos, divisions, dist, amount, first, second, third); vec4 color = texture(uTexture, result.st);return color; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x / uResolution.y;vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos - 0.5), 0.0000); vec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000)); float mDist = ease(0, max(0., 1. - distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.0000)));vec4 col = blinds(uv, mDist); fragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false}},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"vignette","usesPingPong":false,"trackMouse":0.74,"mouseMomentum":1,"parentLayer":"56b1994a-a41b-4341-8959-e2cfa6fbf937","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); } void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); float luma = dot(color.rgb, vec3(0.299, 0.587, 0.114)); float displacement = (luma - 0.5) * 0.0000 * 0.5; vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0); vec2 skew = vec2(0.5000, 1.0 - 0.5000); float halfRadius = 0.3900 * 0.5; float innerEdge = halfRadius - 1.0000 * halfRadius * 0.5; float outerEdge = halfRadius + 1.0000 * halfRadius * 0.5; vec2 pos = vec2(0.5, 0.5);pos += (uMousePos - 0.5) * 0.7400; const float TWO_PI = 6.28318530718; vec2 scaledUV = uv * aspectRatio * rot(-0.0054 * TWO_PI) * skew; vec2 scaledPos = pos * aspectRatio * rot(-0.0054 * TWO_PI) * skew; float radius = distance(scaledUV, scaledPos); float falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius); vec3 finalColor;finalColor = mix(color.rgb, mix(color.rgb, vec3(0, 0, 0), 1.0000), falloff); color = mix(color * (1.-falloff), vec4(finalColor * color.a, color.a), 1.0000); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false}}],"options":{"name":"Copy of De becker code 2","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false,"freePlan":false},"version":"1.4.20","id":"YJPIIhJjSXLM9BWf6ULV"}